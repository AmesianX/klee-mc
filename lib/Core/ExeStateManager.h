/**
 * Cleanly manage states generated by executor
 */
#ifndef EXESTATEMANAGER_H
#define EXESTATEMANAGER_H
#include "klee/ExecutionState.h"
#include "PTree.h"
#include "Searcher.h"

namespace klee
{
class Searcher;

typedef std::map<ExecutionState*, ExecutionState*> ExeStateReplaceMap;

class ExeStateManager
{
private:
	ExeStateSet states;
	ExeStateSet::size_type nonCompactStateCount;

	/// States that have been added during the current instructions step.
	/// \invariant \ref addedStates is a subset of \ref states.
	/// \invariant \ref addedStates and \ref removedStates are disjoint.
	ExeStateSet addedStates;
	/// Used to track states that have been removed during the current
	/// instructions step.
	/// \invariant \ref removedStates is a subset of \ref states.
	/// \invariant \ref addedStates and \ref removedStates are disjoint.
	ExeStateSet removedStates;

	// used when we need to remove yielded states + normal removed states
	mutable ExeStateSet allRemovedStates;

	// States replaced during the current instructions step.
	ExeStateReplaceMap replacedStates;

	/* states to yield */
	ExeStateSet yieldStates;

	/* all yielded states */
	ExeStateSet yieldedStates;

	std::unique_ptr<Searcher> searcher;

	Searcher::States getStates(void) const;
public:
	ExeStateManager();
	virtual ~ExeStateManager();
	void commitQueue(ExecutionState* current = NULL);

	ExeStateSet::const_iterator begin(void) const { return states.begin(); }
	ExeStateSet::const_iterator end(void) const { return states.end(); }
	bool hasState(ExecutionState* st) const{ return states.count(st) != 0; }

	ExeStateSet::const_iterator beginYielded(void) const
	{ return yieldedStates.begin(); }

	ExeStateSet::const_iterator endYielded(void) const
	{ return yieldedStates.end(); }

	const ExeStateSet& getYielded(void) const { return yieldedStates; }

	void dropAdded(ExecutionState* es);
	void queueAdd(ExecutionState* es);
	void queueSplitAdd(
		shared_ptnode	&ptn,
		ExecutionState	*initialState,
		ExecutionState	*newState);

	void queueRemove(ExecutionState* s);
	void yield(ExecutionState* s);
	void forceYield(ExecutionState* s);

	void setInitialState(ExecutionState* initialState);
	void setWeights(double weight);
	void replaceState(ExecutionState* old_s, ExecutionState* new_s);
	void replaceStateImmediate(
		ExecutionState* old_s,
		ExecutionState* new_s,
		ExecutionState** root_to_be_removed = NULL);
	ExecutionState* getReplacedState(ExecutionState* s) const;

	void compactPressureStates(uint64_t maxMem);
	void compactStates(unsigned numToCompact);
	void compactState(ExecutionState* state);


	bool empty(void) const { return size() == 0; }
	unsigned size(void) const
	{ return states.size() + yieldedStates.size(); }

	unsigned numYieldedStates(void) const { return yieldedStates.size(); }
	unsigned numRunningStates(void) const { return states.size(); }
	unsigned numRemovedStates(void) const { return removedStates.size(); }
	bool isRemovedState(ExecutionState* s) const;
	bool isAddedState(ExecutionState* s) const;
	ExecutionState* selectState(bool allowCompact);

	void teardownUserSearcher(void);
	void setupSearcher(std::unique_ptr<Searcher> s);

	unsigned int getNonCompactStateCount(void) const
	{ return nonCompactStateCount; }

	const PTree* getPTree(void) const { return pathTree.get(); }
	PTree* getPTree(void) { return pathTree.get(); }
private:
	ExecutionState* popYieldedState(void);
	void dropAddedDirect(ExecutionState* es);
	void removePTreeState(
		ExecutionState* es,
		ExecutionState** root_to_be_removed);
	void removeRoot(ExecutionState* es);

	std::unique_ptr<PTree>	pathTree;
};

struct KillOrCompactOrdering
// the least important state (the first to kill or compact) first
{
  // Ordering:
  // 1. States with coveredNew has greater importance
  // 2. States with more recent use has greater importance
  bool operator()(
    const ExecutionState* a, const ExecutionState* b) const
  // returns true if a is less important than b
  {
    // replayed states have lower priority than non-replay
    if (!a->isReplayDone() && b->isReplayDone()) return true;

    // state that found fresh branch should rank higher
    if (!a->isOnFreshBranch() &&  b->isOnFreshBranch()) return true;
    if ( a->isOnFreshBranch() && !b->isOnFreshBranch()) return false;

    // state that covered new code should stick around
    if (!a->coveredNew &&  b->coveredNew) return true;
    if ( a->coveredNew && !b->coveredNew) return false;

    return a->lastGlobalInstCount < b->lastGlobalInstCount;
  }
};

}

#endif